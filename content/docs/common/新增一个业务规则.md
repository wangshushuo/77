---
title: "新增一个业务规则"
date: 2022-07-19T17:27:31+08:00
author: 
---

当新增一个业务规则，且“用户规则”列是~~枚举~~或者~~参照~~时，就需要写代码干预。

## 前端处理渲染

apps/link/src/main/screens/archive/bill-type/business-rule

```tsx
export const budgetPlanBusinessRule: { [keys: string]: IBusinessRuleCustomizedDef } = ({
  ['xxId']: {
    cellValueSubmitHandler,
    cellEditor: opt => {
      const { rowField, params } = opt;
      const field = rowField.select('userRule');
      const dataFieldProps: any = {
        ...params,
        field,
        path: field.path,
        type: 'enum',
        enumType: 'ChangeViewType',
      };
      return <AgDataField {...dataFieldProps} />;
    },
    cellRenderer: createCellRender(),
  } as IBusinessRuleCustomizedDef,
})
```
budgetPlanBusinessRule 是单据类型对象。其中的key是业务规则名，value是渲染的参数。dataFieldProps中的type为渲染的类型enum代表枚举，enumType是枚举的名字。

cellValueSubmitHandler和createCellRender是已提供的函数，可以直接使用。

## Go处理返回值

由于后端存的是字符串，对于枚举和参照，存的都是Id，就需要在Go上把Id转化为结构化数据。

如果是枚举用GetEnumValue方法获取结构化数据即可。如果是参照对象，就需要GQL请求会对应的数据了。

trek/web/controllers/web-controllers/bill-type-setting/bill-type-setting.go

在此文件中加一个 case
```go
	case "xxId":
		u, ok := result.UserRule.(string)
		if ok {
			var enumValue = metadata.GetMetadata().GetEnumValue(gen_enums.ENUM_ChangeViewType, u)
			result.UserRule = enumValue
		}
		s, ok := result.SystemRule.(string)
		if ok {
			var enumValue = metadata.GetMetadata().GetEnumValue(gen_enums.ENUM_ChangeViewType, s)
			result.SystemRule = enumValue
		}
```

